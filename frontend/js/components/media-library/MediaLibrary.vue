<template>
  <div class="medialibrary">
    <div class="medialibrary__frame">
      <div class="medialibrary__header" ref="form">
        <a17-filter @submit="submitFilter">
          <ul class="secondarynav secondarynav--desktop" slot="navigation">
            <li class="secondarynav__item" v-for="navType in types" :class="{ 's--on': type === navType.value, 's--disabled' : type !== navType.value && strict }">
              <a href="#" @click.prevent="updateType(navType.value)"><span class="secondarynav__link">{{ navType.text }}</span> <span v-if="navType.total > 0" class="secondarynav__number">({{ navType.total }})</span></a>
            </li>
          </ul>

          <div class="secondarynav secondarynav--mobile secondarynav--dropdown" slot="navigation">
            <a17-dropdown ref="secondaryNavDropdown" position="bottom-left" width="full" :offset="0">
              <a17-button variant="dropdown" size="small" @click="$refs.secondaryNavDropdown.toggle()">
                <span class="secondarynav__link">{{ selectedType.text }}</span><span class="secondarynav__number">{{ selectedType.total }}</span>
              </a17-button>
              <div slot="dropdown__content">
                <ul>
                  <li v-for="navType in types" class="secondarynav__item">
                    <a href="#" v-on:click.prevent="updateType(navType.value)"><span class="secondarynav__link">{{ navType.text }}</span><span class="secondarynav__number">{{ navType.total }}</span></a>
                  </li>
                </ul>
              </div>
            </a17-dropdown>
            <input type="hidden" name="type" :value="type" />
          </div>

          <!-- <div slot="hidden-filters">
          </div> -->
        </a17-filter>
      </div>

      <div class="medialibrary__inner">
        <div class="medialibrary__grid">
          <aside class="medialibrary__sidebar">
            <a17-mediasidebar :selectedMedias="selectedMedias" @clear="clearSelectedMedias" @delete="deleteSelectedMedias"></a17-mediasidebar>
          </aside>
          <footer class="medialibrary__footer" v-if="selectedMedias.length && showInsert && connector">
            <a17-button variant="action" @click="saveAndClose">{{ selectedMedias.length > 1 ? btnMultiLabel : btnLabel }}</a17-button>
          </footer>
          <div class="medialibrary__list" ref="list">
            <a17-uploader @loaded="addMedia" @clear="clearSelectedMedias" :type="type"></a17-uploader>
            <a17-itemlist :items="fullMedias" :selectedItems="selectedMedias" @change="updateSelectedMedias" v-if="type === 'file'"></a17-itemlist>
            <a17-mediagrid :medias="fullMedias" :selectedMedias="selectedMedias" @change="updateSelectedMedias" v-else></a17-mediagrid>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  import { mapState } from 'vuex'
  import api from '../../store/api/media-library'

  import a17MediaSidebar from './MediaSidebar.vue'
  import a17Filter from '../Filter.vue'
  import a17Uploader from './Uploader.vue'
  import a17MediaGrid from './MediaGrid.vue'
  import a17ItemList from '../ItemList.vue'
  import FormDataAsObj from '@/utils/formDataAsObj.js'

  export default {
    name: 'A17Medialibrary',
    components: {
      'a17-filter': a17Filter,
      'a17-mediasidebar': a17MediaSidebar,
      'a17-uploader': a17Uploader,
      'a17-mediagrid': a17MediaGrid,
      'a17-itemlist': a17ItemList
    },
    props: {
      btnLabel: {
        type: String,
        default: 'Insert file'
      },
      btnMultiLabel: {
        type: String,
        default: 'Insert files'
      },
      endpoint: {
        type: String,
        default: ''
      },
      initialPage: {
        type: Number,
        default: 1
      }
    },
    data: function () {
      return {
        showInsert: true,
        maxPage: 20,
        fullMedias: [],
        selectedMedias: [],
        gridHeight: 0,
        page: this.initialPage
      }
    },
    computed: {
      selectedType: function () {
        let self = this
        const navItem = self.types.filter(function (t) {
          return t.value === self.type
        })
        return navItem[0]
      },
      ...mapState({
        connector: state => state.mediaLibrary.connector,
        max: state => state.mediaLibrary.max,
        type: state => state.mediaLibrary.type, // image, video, audio or pdf
        types: state => state.mediaLibrary.types,
        strict: state => state.mediaLibrary.strict
      })
    },
    methods: {
      updateType: function (newType) {
        if (this.strict) return
        if (this.type === newType) return

        this.$store.commit('updateMediaType', newType)
        this.submitFilter()
      },
      addMedia: function (media) {
        let self = this

        // this.selectedMedias = []

        // remove unecessary loading states
        if (media.hasOwnProperty('progress')) delete media.progress
        if (media.hasOwnProperty('error')) delete media.error
        if (media.hasOwnProperty('interval')) delete media.interval

        // add media in first position of the available media
        // see api/media-library for actual ajax
        api.add(media, function (resp) {
          self.fullMedias.unshift(resp)

          // select it
          self.updateSelectedMedias(media.id)
        })
      },
      updateSelectedMedias: function (id) {
        const alreadySelectedMedia = this.selectedMedias.filter(function (media) {
          return media.id === id
        })

        // not already selected
        if (alreadySelectedMedia.length === 0) {
          if (this.max === 1) this.clearSelectedMedias()
          if (this.selectedMedias.length >= this.max && this.max > 0) return

          const mediaToSelect = this.fullMedias.filter(function (media) {
            return media.id === id
          })

          // Add one media to the selected media
          if (mediaToSelect.length) this.selectedMedias.push(mediaToSelect[0])
        } else {
          // Remove one item from the selected media
          this.selectedMedias = this.selectedMedias.filter(function (media) {
            return media.id !== id
          })
        }
      },
      getFormData: function (form) {
        let data = FormDataAsObj(form)

        if (data) data.page = this.page
        else data = { page: this.page }

        return data
      },
      clearSelectedMedias: function () {
        this.selectedMedias.splice(0)
      },
      deleteSelectedMedias: function () {
        this.fullMedias = this.fullMedias.filter((media) => {
          return !this.selectedMedias.includes(media)
        })
        this.selectedMedias.splice(0)
      },
      clearFullMedias: function () {
        this.selectedMedias.splice(0)
        this.fullMedias.splice(0)
      },
      reloadGrid: function () {
        let self = this

        const form = this.$refs.form
        const list = this.$refs.list
        const formdata = this.getFormData(form)

        // see api/media-library for actual ajax
        api.get(this.endpoint, formdata, function (resp) {
          // add medias here
          self.fullMedias.push(...resp.data.items)
          self.maxPage = resp.data.maxPage
          self.$store.commit('updateMediaTypeTotal', { type: self.type, total: resp.data.total })
          // re-listen for scroll position
          self.$nextTick(function () {
            if (self.gridHeight !== list.scrollHeight) {
              self.gridHeight = list.scrollHeight
              list.addEventListener('scroll', self.scrollToPaginate)
            }
          })
        })
      },
      submitFilter: function (formData) {
        // when changing filters, reset the page to 1
        this.page = 1

        this.clearFullMedias()
        this.clearSelectedMedias()
        this.reloadGrid()
      },

      scrollToPaginate: function () {
        const list = this.$refs.list

        if (list.scrollTop + list.offsetHeight > this.gridHeight - 10) {
          list.removeEventListener('scroll', this.scrollToPaginate)

          if (this.maxPage > this.page) {
            this.page = this.page + 1

            this.reloadGrid()
          }
        }
      },
      saveAndClose: function () {
        this.$store.commit('saveSelectedMedias', this.selectedMedias)

        this.$parent.close()
      }
    },
    mounted: function () {
      // bind scroll on the feed
      this.reloadGrid()
    }
  }
</script>

<style lang="scss" scoped>
  @import '~styles/setup/_mixins-colors-vars.scss';

  $width_sidebar: (default: 290px, small: 250px, xsmall: 200px);

  .medialibrary {
    display: block;
    width: 100%;
    min-height: 100%;
    padding: 0;
    position:relative;
  }

  .medialibrary__header {
    background:$color__border--light;
    border-bottom:1px solid $color__border;
    padding:0 20px;

    @include breakpoint(small-) {
      /deep/ .filter__inner {
        flex-direction: column;
      }

      /deep/ .filter__search {
        padding-top: 10px;
      }

      .secondarynav {
        padding-bottom: 10px;
      }

    }
  }

  .medialibrary__frame {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display:flex;
    flex-flow: column nowrap;
  }

  .medialibrary__inner {
    position: relative;
    width: 100%;
    overflow: hidden;
    flex-grow: 1;
  }

  .medialibrary__footer {
    position: absolute;
    right: 0;
    z-index: 76;
    bottom: 0;
    width: map-get($width_sidebar, default); // fixed arbitrary width
    color: $color__text--light;
    padding:10px;
    overflow:hidden;
    background:$color__border--light;
    border-top:1px solid $color__border;

    > button {
      display: block;
      width: 100%;
    }

    @include breakpoint(small) {
      width: map-get($width_sidebar, small);
    }

    @include breakpoint(xsmall) {
      width: map-get($width_sidebar, xsmall);
    }

    @media screen and (max-width: 550px) {
      width: 100%;
    }
  }

  .medialibrary__sidebar {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    width: map-get($width_sidebar, default); // fixed arbitrary width
    padding: 0 0 90px 0;
    z-index: 75;
    background:$color__border--light;
    overflow: auto;

    @include breakpoint(small) {
      width: map-get($width_sidebar, small);
    }

    @include breakpoint(xsmall) {
      width: map-get($width_sidebar, xsmall);
    }

    @media screen and (max-width: 550px) {
      display: none;
    }
  }

  .medialibrary__list {
    margin: 0;
    position: absolute;
    top: 0;
    left: 0;
    right:0;
    bottom: 0;
    overflow: auto;
    padding:10px;
  }

  /* with a sidebar visible */
  .medialibrary__list {
    right:map-get($width_sidebar, default);

    @include breakpoint(small) {
      right: map-get($width_sidebar, small);
    }

    @include breakpoint(xsmall) {
      right: map-get($width_sidebar, xsmall);
    }

    @media screen and (max-width: 550px) {
      right: 0;
    }
  }

</style>
